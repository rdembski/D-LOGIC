from flask import Flask, request, jsonify
import google.generativeai as genai
import logging
import json
import time
import hashlib

# --- KONFIGURACJA ---
API_KEY = "AIzaSyCWXMhf6vuVdB7dhNgbIz--ygBIj6TIx5c" 
PORT = 5000
# Model Flash jest bardzo szybki i wydajny. Je≈õli wolisz Lite, zmie≈Ñ na "models/gemini-1.5-flash-8b"
MODEL_NAME = "models/gemini-2.0-flash-exp" 

# CZAS PAMIƒòCI (CACHE) W SEKUNDACH
# Przez 5 minut (300s) serwer nie zapyta Google o ten sam uk≈Çad rynku.
CACHE_TIMEOUT = 300 

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
app = Flask(__name__)

genai.configure(api_key=API_KEY)

# --- PAMIƒòƒÜ PODRƒòCZNA ---
analysis_cache = {}

# --- M√ìZG D-LOGIC ---
SYSTEM_PROMPT = """
Jeste≈õ D-LOGIC NEURO. Twoim celem jest identyfikacja ANOMALII i WARIACJI w strukturze EURUSD.
W odpowiedzi podaj TYLKO czysty JSON bez formatowania markdown.

Format JSON:
{
  "state": "IMPULSE" | "CORRECTION" | "CHAOS",
  "decision": "EXECUTE" | "WAIT" | "DANGER",
  "direction": "LONG" | "SHORT" | "NONE",
  "confidence": 85,
  "anomaly": "Opis anomalii lub NONE",
  "scenario_a_prob": 65,
  "scenario_b_prob": 35,
  "comment": "Krotka synteza dla tradera."
}
"""

try:
    model = genai.GenerativeModel(
        model_name=MODEL_NAME,
        system_instruction=SYSTEM_PROMPT
    )
    print(f"‚úÖ Pomy≈õlnie za≈Çadowano model: {MODEL_NAME}")
except Exception as e:
    print(f"‚ö†Ô∏è B≈ÇƒÖd ≈Çadowania modelu {MODEL_NAME}: {e}")
    # Fallback
    model = genai.GenerativeModel(model_name="gemini-pro", system_instruction=SYSTEM_PROMPT)

def get_cache_key(data):
    """Tworzy unikalny identyfikator dla danych rynkowych"""
    # ≈ÅƒÖczymy kluczowe parametry w jeden ciƒÖg znak√≥w
    # UWAGA: Nie dodajemy 'time', bo czas zmienia siƒô co sekundƒô i psu≈Çby cache!
    raw_str = f"{data.get('h4')}|{data.get('h1')}|{data.get('zone')}|{data.get('pdh')}|{data.get('cisd')}"
    return hashlib.md5(raw_str.encode()).hexdigest()

@app.route('/analyze', methods=['POST'])
def analyze():
    try:
        raw_data = request.get_data()
        logging.info(f"üì• DANE Z MT5: {raw_data}")

        try:
            clean_json = raw_data.decode('utf-8').strip('\x00')
            data = json.loads(clean_json)
        except Exception as e:
            logging.error(f"‚ö†Ô∏è B≈ÇƒÖd JSON: {e}")
            return jsonify({"error": "Invalid JSON"}), 400

        # --- 1. SPRAWDZANIE CACHE (Oszczƒôdzanie API) ---
        cache_key = get_cache_key(data)
        current_time = time.time()

        if cache_key in analysis_cache:
            cached_item = analysis_cache[cache_key]
            age = current_time - cached_item['time']
            
            if age < CACHE_TIMEOUT:
                logging.info(f"‚ôªÔ∏è U≈ªYWAM PAMIƒòCI CACHE (Oszczƒôdzono limit API). Wiek: {int(age)}s")
                return cached_item['response'], 200
            else:
                logging.info("‚åõ Cache wygas≈Ç. Od≈õwie≈ºam analizƒô...")

        # --- 2. PRZYGOTOWANIE DANYCH DLA AI ---
        market_data = f"""
        ANALIZA EURUSD:
        Trend H4: {data.get('h4')}
        Trend H1: {data.get('h1')}
        Strefa: {data.get('zone')}
        P≈Çynno≈õƒá: {data.get('pdh')}
        Sygna≈Çy: {data.get('cisd')}
        Czas sesji: {data.get('time')}
        """
        
        logging.info("üß† PROCESOR MY≈öLI (Wysy≈Çanie do Google)...")
        
        # --- 3. KOMUNIKACJA Z GOOGLE ---
        response = model.generate_content(market_data)
        text_response = response.text.replace("```json", "").replace("```", "").strip()
        
        # --- 4. ZAPIS DO CACHE ---
        analysis_cache[cache_key] = {
            "response": text_response,
            "time": current_time
        }
        
        logging.info(f"üì§ ODPOWIED≈π AI (NOWA): {text_response}")
        return text_response, 200

    except Exception as e:
        error_msg = str(e)
        # Obs≈Çuga b≈Çƒôdu 429 (Quota)
        if "429" in error_msg:
            logging.error("‚è≥ PRZEKROCZONO LIMIT ZAPYTA≈É (QUOTA). ODCZEKAJ CHWILƒò.")
            return jsonify({
                "decision": "WAIT", 
                "comment": "AI RECHARGING (API LIMIT). WAIT 1 MIN.", 
                "confidence": 0, 
                "state": "LIMIT"
            }), 200 
            
        logging.error(f"‚ùå B≈ÅƒÑD KRYTYCZNY: {error_msg}")
        return jsonify({"error": error_msg}), 500

if __name__ == '__main__':
    print(f"üöÄ SERVER D-LOGIC (CACHE ENABLED) GOTOWY NA PORTCIE {PORT}")
    print(f"‚è±Ô∏è Czas pamiƒôci podrƒôcznej: {CACHE_TIMEOUT} sekund")
    app.run(host='0.0.0.0', port=PORT)